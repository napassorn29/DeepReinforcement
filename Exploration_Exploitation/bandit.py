import numpy as np
from numpy import random
import matplotlib.pyplot as plt
import random

# set up MultiArmBandit class
class MultiArmBandit():
    def __init__(self, num_bandits:int, rewards=None, prob_reward=None):
        self.num_bandits = num_bandits
        
        # check if rewards and prob_reward are None (user not given any input for rewards and prob_reward)
        if rewards is None:
            rewards = []
        if prob_reward is None:
            prob_reward = []
        
        # random rewards and prob_reward if user not given any input for rewards and prob_reward
        if not rewards and not prob_reward:
            for i in range(num_bandits):
                # random number of rewards for each bandit
                num_reward = np.random.randint(2,7)
                rewards.append(random.sample(range(-10, 10), k=num_reward))
                # random probability for each reward
                num_prob = random.sample(range(0, 10), num_reward)
                # sum of probability for each bandit must be 1
                sum_num_prob = sum(num_prob)
                prob = []
                for j in range(len(num_prob)):
                    if j == len(num_prob)-1:
                        prob.append(round(1-sum(prob),2))
                    else:
                        prob.append(round(num_prob[j]/sum_num_prob,2))
                prob_reward.append(prob)

        # check if rewards and prob_reward are given
        if len(rewards) == num_bandits and len(prob_reward) == num_bandits:
            check_num_bandits = True
            for i in range(num_bandits):
                # check if sum of prob_reward is 1 if not raise ValueError
                if round(sum(prob_reward[i]), 2) != 1.00:
                    raise ValueError('Sum of prob_reward must be 1')
                # check if number of rewards and prob_reward must match number of arms per bandit
                if len(rewards[i]) != len(prob_reward[i]):
                    check_num_bandits = False
                    raise ValueError('Number of rewards and prob_reward must match number of arms per bandit')
            # check if number of rewards and prob_reward must match number of bandits
            if check_num_bandits:
                self.reward = rewards
                self.prob_reward = prob_reward
                
        # raise ValueError if number of rewards and prob_reward not match number of bandits
        if len(rewards) != num_bandits or len(prob_reward) != num_bandits:
            raise ValueError('Number of rewards and prob_reward must match number of bandits')

    # pull arm method to get true reward for each bandit 
    def pull_arm(self):
        true_reward = []
        for i in range(self.num_bandits):
            rewards = self.reward[i]
            probabilities = self.prob_reward[i]
            # random reward for each bandit
            reward = np.random.choice(rewards, p=probabilities)
            true_reward.append(reward)
        return true_reward
    
    # method to get reward*prob_reward for each bandit(expectation reward)
    def expectation_reward(self):
        expectation_reward = []
        for i in range(self.num_bandits):
            prob_each_action = 0
            # reward*prob_reward for each bandit
            for j in range (len(self.reward[i])):
                prob_each_action = prob_each_action + (self.reward[i][j]*self.prob_reward[i][j])
            expectation_reward.append(round(prob_each_action,4))
        return expectation_reward