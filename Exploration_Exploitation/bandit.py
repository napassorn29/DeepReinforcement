import numpy as np
from numpy import random
import matplotlib.pyplot as plt
import random

class MultiArmBandit():
    def __init__(self, num_bandits:int, rewards=None, prob_reward=None):
        self.num_bandits = num_bandits
        
        if rewards is None:
            rewards = []
        if prob_reward is None:
            prob_reward = []
            
        if not rewards and not prob_reward:
            for i in range(num_bandits):
                num_reward = np.random.randint(2,7)
                rewards.append(random.sample(range(-10, 10), k=num_reward))
                num_prob = random.sample(range(0, 10), num_reward)
                sum_num_prob = sum(num_prob)
                prob = []
                for j in range(len(num_prob)):
                    if j == len(num_prob)-1:
                        prob.append(round(1-sum(prob),2))
                    else:
                        prob.append(round(num_prob[j]/sum_num_prob,2))
                prob_reward.append(prob)

        if len(rewards) == num_bandits and len(prob_reward) == num_bandits:
            check_num_bandits = True
            for i in range(num_bandits):
                if round(sum(prob_reward[i]), 2) != 1.00:
                    raise ValueError('Sum of prob_reward must be 1')
                if len(rewards[i]) != len(prob_reward[i]):
                    check_num_bandits = False
                    raise ValueError('Number of rewards and prob_reward must match number of arms per bandit')
            if check_num_bandits:
                self.reward = rewards
                self.prob_reward = prob_reward
                
        if len(rewards) != num_bandits or len(prob_reward) != num_bandits:
            raise ValueError('Number of rewards and prob_reward must match number of bandits')


    def pull_arm(self):
        true_reward = []
        for i in range(self.num_bandits):
            rewards = self.reward[i]
            probabilities = self.prob_reward[i]
            reward = np.random.choice(rewards, p=probabilities)
            true_reward.append(reward)
            
        return true_reward
    
    def prob_action(self):
        prob_action = []
        for i in range(self.num_bandits):
            prob_each_action = 0
            for j in range (len(self.reward[i])):
                prob_each_action = prob_each_action + (self.reward[i][j]*self.prob_reward[i][j])
            prob_action.append(round(prob_each_action,4))
        return prob_action
    
    
# bandit = MultiArmBandit(3, [[-2, 0, 2, 4], [2, 3, 0, 4], [5, -5, 0]], [[0.4, 0.2, 0.3, 0.1], [0.2, 0.1, 0.5, 0.2], [0.2, 0.5, 0.3]])
# bandit = MultiArmBandit(3,[[-2,0,2,4],[2,3,0,4],[5,-5,10]],[[0.4,0.2,0.3,0.1],[0.2,0.1,0.5,0.2],[0.2,0.5,0.3]])
# print(bandit.reward)
# print(bandit.prob_reward)
# print(bandit.pull_arm())
# print(bandit.prob_action())

# bandit1 = MultiArmBandit(3,[[-2,0,2,4],[2,3,0,4],[5,-5,10]],[[0.4,0.2,0.3,0.1],[0.2,0.1,0.5,0.2],[0.2,0.5,0.3]])
# print(bandit1.reward)
# print(bandit1.prob_action())